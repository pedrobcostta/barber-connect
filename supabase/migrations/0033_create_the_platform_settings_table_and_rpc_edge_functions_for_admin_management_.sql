-- 1. Create the table to store platform-wide settings
CREATE TABLE IF NOT EXISTS public.platform_settings (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    key TEXT NOT NULL UNIQUE,
    value TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 2. Enable RLS and set policies
ALTER TABLE public.platform_settings ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Admins can read settings" ON public.platform_settings;
CREATE POLICY "Admins can read settings" ON public.platform_settings
FOR SELECT USING (get_my_role() = 'admin');

-- Note: Updates will be handled by a secure Edge Function, not direct RLS policy.

-- 3. Create RPC function to list admin users
CREATE OR REPLACE FUNCTION list_admins()
RETURNS TABLE (id UUID, full_name TEXT, email TEXT, created_at TIMESTAMPTZ)
LANGUAGE plpgsql
SECURITY DEFINER SET search_path = ''
AS $$
BEGIN
    IF get_my_role() <> 'admin' THEN
        RAISE EXCEPTION 'Forbidden: User is not an admin';
    END IF;

    RETURN QUERY
    SELECT p.id, p.full_name, u.email, u.created_at
    FROM public.profiles p
    JOIN auth.users u ON p.id = u.id
    WHERE p.role = 'admin';
END;
$$;

-- 4. Create RPC function to get platform settings
CREATE OR REPLACE FUNCTION get_platform_settings()
RETURNS SETOF public.platform_settings
LANGUAGE plpgsql
SECURITY DEFINER SET search_path = ''
AS $$
BEGIN
    IF get_my_role() <> 'admin' THEN
        RAISE EXCEPTION 'Forbidden: User is not an admin';
    END IF;

    RETURN QUERY
    SELECT * FROM public.platform_settings;
END;
$$;